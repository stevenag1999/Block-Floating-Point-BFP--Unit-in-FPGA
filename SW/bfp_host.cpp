#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
#include <cstdint>
#include <cstdlib>

// XRT includes (experimental C++ API)
#include "experimental/xrt_device.h"
#include "experimental/xrt_kernel.h"
#include "experimental/xrt_bo.h"

#include "common_bfp.h"

// Path to xclbin generated by HW flow
static const std::string kXclbinPath = "../HW/package.hw/kernels.xclbin";

static void print_usage(const char* exe) {
    std::cerr << "Usage: " << exe << " <operation_id> <n_blocks>\n";
    std::cerr << "  operation_id:\n";
    std::cerr << "    0 = ENCODE\n";
    std::cerr << "    1 = DECODE\n";
    std::cerr << "    2 = ADD\n";
    std::cerr << "    3 = SUB\n";
    std::cerr << "    4 = MUL\n";
    std::cerr << "    5 = DIV\n";
    std::cerr << "    6 = RCP\n";
}

static const char* op_name(unsigned op) {
    if (op > 6)
        return "UNKNOWN";
    return OP_NAMES[op];
}

int main(int argc, char* argv[])
{
    try {
        if (argc < 3) {
            print_usage(argv[0]);
            return 1;
        }

        unsigned op_id   = static_cast<unsigned>(std::stoul(argv[1]));
        unsigned nBlocks = static_cast<unsigned>(std::stoul(argv[2]));
        if (nBlocks == 0) {
            std::cerr << "ERROR: n_blocks must be > 0\n";
            return 1;
        }

        const unsigned BlockSize = N;
        const unsigned totalSize = nBlocks * BlockSize;

        std::cout << "BFP Accelerator Test\n";
        std::cout << "Operation: " << op_name(op_id) << " (" << op_id << ")\n";
        std::cout << "Number of blocks: " << nBlocks << "\n";
        std::cout << "Block size (N): " << BlockSize << "\n";

        // --------------------------------------------------------------------
        // Open device and load xclbin
        // --------------------------------------------------------------------
        std::cout << "Open the device 0\n";
        xrt::device device(0);

        std::cout << "Load the xclbin " << kXclbinPath << "\n";
        auto uuid = device.load_xclbin(kXclbinPath);

        std::cout << "Create kernel handle\n";
        xrt::kernel bfp_kernel(device, uuid, "bfp_kernel");

        // --------------------------------------------------------------------
        // Prepare host-side data
        // --------------------------------------------------------------------
        std::cout << "Prepare host data\n";

        // Same test vectors as tb_kernel.cc
        float A0[BlockSize] = {
            12.35f,  6.50f, 10.20f,  6.60f,  8.80f,  2.56f, 11.11f,  8.00f,
             5.45f,  9.99f,  0.15f, 18.00f,  3.80f, 90.10f, 14.00f, 10.00f
        };
        float A1[BlockSize] = {
             0.0f,  1.0f,  2.0f,  3.0f,  4.0f,  5.0f,  6.0f,  7.0f,
             8.0f,  9.0f,  0.01f, 0.02f, 0.03f, 0.04f, 0.05f, 0.06f
        };
        float B0[BlockSize] = {
            -2.0f, 0.0f, -2.0f, 3.0f, 2.0f, 2.0f, 2.0f, 2.0f,
             3.0f, 3.0f,  5.0f, 3.0f, 6.0f, 3.0f, 8.0f, 2.0f
        };
        float B1[BlockSize] = {
            15.0f, 14.0f, 13.0f, 12.0f, 11.0f, 10.0f, 9.0f, 8.0f,
             7.0f,  6.0f,  5.0f,  4.0f,  3.0f,  2.0f, 1.0f, 0.5f
        };

        // Host buffers corresponding to kernel ports
        std::vector<float>        h_in_fp32_a(totalSize, 0.0f);
        std::vector<unsigned int> h_in_exp_a(nBlocks, 0);
        std::vector<unsigned int> h_in_sign_a(totalSize, 0);
        std::vector<unsigned int> h_in_mant_a(totalSize, 0);

        std::vector<unsigned int> h_in_exp_b(nBlocks, 0);
        std::vector<unsigned int> h_in_sign_b(totalSize, 0);
        std::vector<unsigned int> h_in_mant_b(totalSize, 0);

        std::vector<float>        h_out_fp32(totalSize, 0.0f);
        std::vector<unsigned int> h_out_exp(nBlocks, 0);
        std::vector<unsigned int> h_out_sign(totalSize, 0);
        std::vector<unsigned int> h_out_mant(totalSize, 0);

        // Fill FP32 inputs with patterns A0/A1
        for (unsigned blk = 0; blk < nBlocks; ++blk) {
            const float* srcA = (blk % 2 == 0) ? A0 : A1;
            const float* srcB = (blk % 2 == 0) ? B0 : B1;
            unsigned base = blk * BlockSize;
            for (unsigned i = 0; i < BlockSize; ++i) {
                h_in_fp32_a[base + i] = srcA[i];
                (void)srcB; // B se usará cuando encadenes ENCODE+OP
            }
        }

        // --------------------------------------------------------------------
        // Allocate device buffers (device-only to evitar userptr)
        // --------------------------------------------------------------------
        std::cout << "Allocate Buffers in Global Memory\n";

        auto flags = xrt::bo::flags::device_only;

        auto bo_in_fp32_a = xrt::bo(device,
                                    h_in_fp32_a.size() * sizeof(float),
                                    flags,
                                    bfp_kernel.group_id(0)); // gmem0
        auto bo_in_exp_a  = xrt::bo(device,
                                    h_in_exp_a.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(1)); // gmem1
        auto bo_in_sign_a = xrt::bo(device,
                                    h_in_sign_a.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(2)); // gmem2
        auto bo_in_mant_a = xrt::bo(device,
                                    h_in_mant_a.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(3)); // gmem3

        auto bo_in_exp_b  = xrt::bo(device,
                                    h_in_exp_b.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(1)); // gmem1
        auto bo_in_sign_b = xrt::bo(device,
                                    h_in_sign_b.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(2)); // gmem2
        auto bo_in_mant_b = xrt::bo(device,
                                    h_in_mant_b.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(3)); // gmem3

        auto bo_out_fp32  = xrt::bo(device,
                                    h_out_fp32.size() * sizeof(float),
                                    flags,
                                    bfp_kernel.group_id(0)); // gmem0
        auto bo_out_exp   = xrt::bo(device,
                                    h_out_exp.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(1)); // gmem1
        auto bo_out_sign  = xrt::bo(device,
                                    h_out_sign.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(2)); // gmem2
        auto bo_out_mant  = xrt::bo(device,
                                    h_out_mant.size() * sizeof(unsigned int),
                                    flags,
                                    bfp_kernel.group_id(3)); // gmem3

        // --------------------------------------------------------------------
        // Transfer input data to device (usa write(ptr, size, 0))
        // --------------------------------------------------------------------
        std::cout << "Write input buffers to device\n";

        bo_in_fp32_a.write(h_in_fp32_a.data(),
                           h_in_fp32_a.size() * sizeof(float),
                           0);
        bo_in_exp_a.write (h_in_exp_a.data(),
                           h_in_exp_a.size()  * sizeof(unsigned int),
                           0);
        bo_in_sign_a.write(h_in_sign_a.data(),
                           h_in_sign_a.size() * sizeof(unsigned int),
                           0);
        bo_in_mant_a.write(h_in_mant_a.data(),
                           h_in_mant_a.size() * sizeof(unsigned int),
                           0);

        bo_in_exp_b.write (h_in_exp_b.data(),
                           h_in_exp_b.size()  * sizeof(unsigned int),
                           0);
        bo_in_sign_b.write(h_in_sign_b.data(),
                           h_in_sign_b.size() * sizeof(unsigned int),
                           0);
        bo_in_mant_b.write(h_in_mant_b.data(),
                           h_in_mant_b.size() * sizeof(unsigned int),
                           0);

        // --------------------------------------------------------------------
        // Launch kernel
        // --------------------------------------------------------------------
        std::cout << "Launch kernel\n";

        auto run = bfp_kernel(
            op_id,
            nBlocks,
            bo_in_fp32_a,
            bo_in_exp_a,
            bo_in_sign_a,
            bo_in_mant_a,
            bo_in_exp_b,
            bo_in_sign_b,
            bo_in_mant_b,
            bo_out_fp32,
            bo_out_exp,
            bo_out_sign,
            bo_out_mant
        );

        run.wait();

        // --------------------------------------------------------------------
        // Read back results (usa read(ptr, size, 0))
        // --------------------------------------------------------------------
        std::cout << "Read back results\n";

        bo_out_fp32.read(h_out_fp32.data(),
                         h_out_fp32.size() * sizeof(float),
                         0);
        bo_out_exp.read (h_out_exp.data(),
                         h_out_exp.size()  * sizeof(unsigned int),
                         0);
        bo_out_sign.read(h_out_sign.data(),
                         h_out_sign.size() * sizeof(unsigned int),
                         0);
        bo_out_mant.read(h_out_mant.data(),
                         h_out_mant.size() * sizeof(unsigned int),
                         0);

        // --------------------------------------------------------------------
        // Print a small summary
        // --------------------------------------------------------------------
        std::cout << "\n=== RESULT SUMMARY (first block) ===\n";

        if (op_id == 0) { // ENCODE: BFP en out_exp/out_sign/out_mant
            std::cout << "Encoded BFP (block 0):\n";
            std::cout << "  exp_shared = " << h_out_exp[0] << "\n";
            std::cout << "  sign[0..7] =";
            for (unsigned i = 0; i < std::min(8u, BlockSize); ++i)
                std::cout << " " << h_out_sign[i];
            std::cout << "\n  mant[0..7] =";
            for (unsigned i = 0; i < std::min(8u, BlockSize); ++i)
                std::cout << " " << h_out_mant[i];
            std::cout << "\n";
        }
        else if (op_id == 1) { // DECODE: FP32 en out_fp32
            std::cout << "Decoded FP32 (block 0):\n";
            for (unsigned i = 0; i < std::min(8u, BlockSize); ++i)
                std::cout << "  [" << i << "] = " << h_out_fp32[i] << "\n";
        }
        else {
            std::cout << "Operation " << op_name(op_id) << " executed.\n";
            std::cout << "  (Validación numérica completa para ops binarias\n"
                      << "   aún no está implementada en este host.)\n";
        }

        std::cout << "\nTEST COMPLETED OK\n";
        return 0;
    }
    catch (const std::exception& ex) {
        std::cerr << "EXCEPTION: " << ex.what() << "\n";
        return 1;
    }
    catch (...) {
        std::cerr << "UNKNOWN EXCEPTION\n";
        return 1;
    }
}
